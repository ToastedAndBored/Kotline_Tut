---

---
`Kotlin tutorial for Toasty by ASCIIMoth`
# Ссылки
- [Онлайн песочница для выполнения кода в браузере](https://play.kotlinlang.org)
- [Официальный тур по языку](https://kotlinlang.org/docs/kotlin-tour-welcome.html)
- [И еще один официальный материал но уже точно для людей имеющих какой-то опыт](https://kotlinlang.org/docs/basic-syntax.html)
- [И еще один](https://play.kotlinlang.org/byExample/01_introduction/01_Hello%20world)
- [Geeks4Geeks](https://www.geeksforgeeks.org/kotlin-programming-language/)котлина
- [w3schools](https://www.w3schools.com/kotlin/index.php) (самое понятное и целостное на фоне остальных)

# Предисловие
В целом все источники объясняют все +- одинаково: базовые вещи описываются подробно, а где-то начиная с `ООП` начинаются такие объяснения, для понимания которых уже нужно знать что такое `ООП` как таковое.
По этому тут будут вперемешку ссылки на разные источники и мои пояснения, так чтобы из этого сложилась понятная картина.

И да, многие вещи упоминаются в одном месте, а объясняются сильно ниже. Без этого никак. Если ты не понял что-то но ниже про это есть глава, не надо задерживаться на вопросе сейчас.

Внизу статьи есть [[#Словарь]] в который ты можешь записывать новые для себя термины по ходу дела
## Исполнение кода
Я обычно за то чтобы для начала устанавливать базовый [[README#^1|тулчейн]] и дергать его руками без помощи `IDE` и прочих слоев абстракции и уже поняв как все устроенно внутри переходить к продвинутым средствам разработки. Но у котлина (как и многих вещей связанных с миром java) тулчейн довольно монструозный, так что до тех пор пока это не будет явно указанно в соответствующей главе, используй [браузерную песочницу](https://play.kotlinlang.org).

Содержимое этой статьи разбито на блоки. В каждом блоке есть одна или несколько ссылок на внешние источники и (опционально) мои пояснения.
Также в большинстве блоков есть строка ==Заменить своей заметкой== вместо который ты должен записать своими словами изученный материал.
К некоторым блокам приложены задания. Это предварительно написанный код, который надо дописать в соответствии с задачей так чтобы он заработал. Рядом с зданиями есть чекбокс. Отмечай его, когда решаешь задания, чтобы я знал что проверять.
И свои заметки и решения задач ты должен дописывать прямо сюда в текст статьи и коммитить на гитхаб.

# Язык
Kotlin это язык созданный в 2016 году конторой JetBrains, которая де юре иностранная, но де факто изначально Питерская. Назван в честь острова [Котлин](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%82%D0%BB%D0%B8%D0%BD) там же под Питером.

Kotlin изначально работает на основе JVM(виртуальной машины java) из за чего у него с жавой очень хороший интероп. Библиотеки на java можно использовать в проектах на kotlin и наоборот. Из-за этого с момента своего появления kotlin сразу имеет обширную экосистему из java мира в котором есть библиотеки для вобще всего. Также по скольку JVM работает вобще на всем чем можно, kotlin тоже получает это свойство. В какой то момент google даже принял kotlin в качестве официального языка для разработки под андроид.
Однако к текущему моменту котлин обзавелся помимо JVM поддержкой кучи других платформ, от транспиляции в JavaScript до компиляции в нативные бинарники. Прямо сейчас прикручивают копиляцию в wasm. Ну и в принципе язык старается стать универсальным.

Также как у Dart с Flutter'ом, у котлина есть свой крупный фреймворк для интерфейсов вокруг которого много чего крутится в экосистеме - Compose. Изначально он был создан для андроида, но потом у него появилась кросплатформенная версия. Сейчас на нем можно и под андроид/ios писать и под десктоп и сайты делать

# Синтаксис
Kotlin относится к семейству `C like` языков т.е. заимствует синтаксис у C.

Код состоит из выражений. Выражением является любая синтаксическая конструкция которая может быть выполнена:
```kotlin
// Это вражение
1 + 2
// Это тоже выражение
print("A")
// Присвоение это тоже выражение
a = 1

// Выражения могут вкладываться друг в друга
// В таком случае они будут исполняться в порядке от наиболее вложенного к наименее

// Здесь сначала выполниться 1+2 что даст 3
// а затем выполнится print(3), что напечатает "3" в консоль
print(1+2)

// Здесь сначала выполнится 2+3 что даст 5
// а затем a = 5, что присвоит переменной a знаение 5
a = 2 + 3
```
В конце выражений используется `;`, но опционально. Если на одной строчке находится только одно выражение, точка с запятой не нужна. Если же несколько выражений записаны в одну строчку, их надо разделять `;`:
```kotlin
println("A")
println("B")
```
``` kotlin
println("A"); println("B")
```
Несколько выражений выполняющихся друг за другом могут быть сгруппированы в `блок кода` с помощью фигурных скобок:
```kotlin
{
	print("A")
	print("B");print("C")
}
```
Блоки кода используются в функциях, циклах, условиях и вообще много где.
Принято внутри каждого блока кода добавлять дополнительный отступ:
```kotlin
{
	{
		{
			print("A")
		}
	}
}
```
Это делает код более читаемым, позволяя легко определять границы блоков на глаз.

Однако ничего не мешает написать весь блок в одну строчку, особенно если в нем только одно выражение
```kotlin
{print("A")}
```

# Ключевые слова
Ключевые слова, это слова которые сами по себе что-то значат в языке. Их нельзя использовать для чего либо кроме их предназначения, нельзя создавать переменные или функции с такими именами и тд. Функционал и правила применения ключевых слов это данность и они в общем то и составляют сам язык.
Список ключевых слов котлина
```kotlin
as break class continue do else false for fun if in is null object package return super this throw true try typealias typeof val var when while
```

#  Комментарии
- https://www.w3schools.com/kotlin/kotlin_comments.php
Комментарии это способ исключить часть текста из программы. Текст в комментариях игнорируется компилятором и не влияет на работу программы.
Комментарии можно (и нужно) использовать для объяснения того как работает код. Хоть сколько-то крупные объемы кода без комментариев сложно воспринимать даже написавшему их человеку через время, не говоря уже о других людях. Как известно `Код чаще читается чем пишется`, по этому писать комментарии важно всегда, даже если кажется что код очевиден.
Также комментарии можно использовать чтобы "выключить" кусок кода, оставив его при этом в файле.
Комментарий можно объявить двумя способами
С двух слешей начинается однострочный комментарий и продолжается до конца строки
```kotlin
// Это комментари
print("A") // И это тоже
```
Со слеша и астериска(звездочки `*`) и заканчивается ими же но в обратном порядке
```kotlin
/* Такой комментарий тоже может быть однострочным */
/* Или
состоять
из
какаого
угодно
колличества
строк
*/
```


# Точка входа
Точка входа (entry point) это место с которого начинается выполнение кода. В kotlin (как и во многих других языках) это функция main ( подробнее о функциях далее).
Выглядит это так
``` kotlin
fun main() {
	/* Когда программа запустится
	содержимое этого блока кода будет выполнено*/
}
```

# Печать
В kotlin есть встроенная функция `println` для печати текста в стандартный поток вывода `stdout`.
```kotlin
println("A")
println("B")
```
Она печатает текст, но ее также можно использовать для того чтобы печатать текстовое представление других типов данных, например чисел:
```kotlin
println(2+3)
```
Функция `println` автоматически переносит курсор на новую строку после каждой печати:
```kotlin
/* Будет напечатано:
A
B
C
*/
fun main() {
	println("A")
	println("B")
	println("C")
}
```
Также есть похожая функция `print` которая не переносит курсор:
```kotlin
/* Будет напечатано:
ABC
*/
fun main() {
	print("A")
	print("B")
	print("C")
}
```

- [x] Задание 1
```kotlin
fun main() {
	/* Напиши код который печатает в одну строчку: */
	// A2B
	/* При этом не используя в коде цифру 2 */
	print("A")
    print(1+1)
    print("B")
	
}
```

# Переменные
- https://www.w3schools.com/kotlin/kotlin_variables.php
- https://www.geeksforgeeks.org/kotlin-variables/
==Переменные - это контейнеры для хранения значений данных, переменные в котлине обозначаются ключевыми словами var и val, типы данных для переменных определяются автоматически по тому что в них записано, но можно и самому обозначить типы данных вручную. Переменные также имеют свою зону применения, ограниченную фигурными скобками(блоком кода), также можно написать переменные за блоком кода, тогда их можно применять вне зависимости от фигурных скобок. Переменные не могут быть не обозначенными заранее.==
- [x] Задание 2
Чем неизменяемые переменные отличаются от констант?
==В языке Котлин не существует констант, но всё ещё есть неизменяемые переменные обозначающиеся ключевым словом val, которым можно присвоить значение только один раз==
- [x] Задание 3
Что такое область видимости (scope)?
==Область видимости - это пространство в пределах которго существуют переменные работы с ними. Область видимости может быть вложенной в другую, в таком случае она наследует все переменные из родительской. Новый блок кода создаёт новую область видимости. Также существует глобальная область видимости, находящаяся вне блоков кода.==
- [x] Задание 4
```kotlin
fun main() {
	var x = 1
	run {
		//Исправь эту строчку так чтобы при запуске программы печаталась двойка:
		//var x = 2 
		x = 2
	}
	print(x)
}
```

# Типы и значения
- https://www.w3schools.com/kotlin/kotlin_data_types.php
- https://kotlinlang.org/docs/unsigned-integer-types.html

==В Котлине тип переменной определяется ее значением или же его можно задать вручную. Типы данных делятся на различные группы:  Numbers/Characters/Boolean/Strings/Arrays.==
==Numbers подразделяется на две отдельные группы: Целочисленные(Byte/Short/Int/Long), Числа с плавающей точкой(Float/Double).==
==Byte = от -128 до 127==
==Short = от -32768 до 32767 ==
==Int = от -2147483648 до 2147483647==
==Long = от -9223372036854775807 до 9223372036854775807 и на конце должно быть "L"==
==Точность значения с плавающей запятой указывает, сколько цифр может иметь значение после десятичной точки. Точность Float составляет всего шесть или семь десятичных цифр, тогда как переменные Double имеют точность около 15 цифр. Поэтому для большинства вычислений безопаснее использовать Double.
Также значение типа Float должно заканчиваться буквой «F».==
==Чтобы преобразовать числовой тип данных в другой тип, необходимо использовать одну из следующих функций: toByte(), toShort(), toInt(), toLong(), toFloat(), toDouble() или toChar().==
==Также существуют беззнаковые целочисленные типы данных с припиской "U" в которые можно записать не отрицательное целочисленное число в определённом диапозоне, также в конце числа должно стоять "u" . Чаще всего приминяется для более низкоуровневых задач где нужна работа непосредственно с байтами, также вариант использования беззнаковых чисел - использование полного битового диапазона целого числа для представления положительных значений. Например, для представления шестнадцатеричных констант, которые не подходят для знаковых типов, таких как цвет, в 32-битном формате AARRGGBB.==


## Тип Char
Изначально тип с именем `char` появился в языке C. Это было без знаковое целое число размером 1 байт = 8 бит. Т.е. в переменной типа `char` могли быть значения от 0 до 255 включительно. И по функционалу это обычные числа с которыми можно было делать обычные арифметические действия. Этот тип можно было назвать как угодно, но в те времена использовалась кодировка `ASCII` в которой каждый символ обозначался как раз одно байтовым целым числом. По этому числовой тип был назван `char` от `character` - символ. Никакого отдельного типа для текстовых символов не было и они просто обозначались соответствующими им числами. А строки соответственно обозначались массивами чисел.
Но очень быстро появлялись новые кодировки. 256 вариантов значения одного байта не было достаточно чтобы вместить в них все языки и символы. Появлялись кодировки с двумя и даже четырьмя байтами на символ. В итоге через какое-то время все приняли UNICODE UTF-8 в котором разные символы вообще записывались разным количеством байт (1 или 2).
Таким образом изначальный смысл названия char полностью потерялся. Тем не менее многие C-подобные языки его унаследовали.
И вот тут начинается цирк.
В части языков `char` это чисто числовой тип, а для символов есть какой-то другой. В части языков, наоборот, это тип только для символов, а для одно байтовых без знаковых чисел отдельный тип.
В Kotlin `char` это тип которому соответствуют только корректные UTF-8 UNICODE символы. Но под капотом это обычное двухбайтовое число. Т.е. по сути тип `short`. Однако записывать туда произвольные числа нельзя т.к. так можно случайно все сломать введя невалидное значение. Чтобы получить символ по его числовому идентификатору, можно использовать функции преобразования типов которые описаны в статье по ссылке выше.
Подробнее о `char`'ах будет в главе про строки.
- [x] Задание 5
```kotlin
fun main() {
	// Добавь что-то в конец следующей строки чтобы программа заработала
	val letter: Char = 66.toChar() //В конце добавлено .toChar()
	println(letter)
}}
```
==В Котлине нет не явного преобразования типов==
## Переменная, тип, значение
Эти три понятия сильно связанны между собой так что важно различать их, чтобы сформировать в голове правильную ментальную модель:
- `Переменная` это ячейка памяти в которую можно положить что либо. Классической аналогией является коробка. В коробку можно класть вещи, доставать их оттуда, заменять другими и тд. Переменные как правило именованы, т.е. имеют имя по которому к ним можно обращаться чтобы достать из них содержимое, положить в них что-либо и тд.
- `Значение` это то, что находится внутри переменной. В нашей аналогии, это содержимое коробки. Значением например является число `10` или строка `Hello world`. Значения можно помещать в переменные, доставать их из  переменных, передавать в функции, возвращать из функций (о функциях ниже) и тд. Важно понимать что имя переменной НЕ связанно ни с каким значением напрямую. Имя переменной указывает только на саму ячейку памяти. Сейчас в ней может лежать одно значение, а потом другое. В то же время одинаковое значение может лежать в нескольких переменных.
- `Тип` это характеристика значения. Значения сами по себе это просто какие-то данные. Чтобы работать с данными нам нужно знать их свойства, какие действия с ними можно делать и как они себя при этом будут вести. Вот это и описывает тип. У любого значения должен быть тип чтобы мы могли знать как с ним работать. Например `Int` это тип, а числа `10`, `20`, `-145` это значения с типом `Int`(корректно можно говорить и `значение А с типом Б` и `значение А типа Б`). В аналогии можно сказать что тип это чертеж, а значения это конкретные изделия сделанные по чертежу. Kotlin - статически типизированный язык. Это значит что в нем тип также должен быть у каждой переменной, он назначается единожды и не может быть изменен. В переменную можно класть значения только того типа, который этой переменной назначен. Котлин достаточно умен, чтобы в некоторых случаях автоматически определять тип переменной, смотря на то, что в нее кладется, в остальных случаях нужно указать тип явно руками. Существуют также динамически типизированные языки в которых за переменной не закреплен никакой тип и в любую переменную можно положить любое значение, например сначала число а потом строку. Динамическая типизация часто упрощает код и уменьшает количество текста. Но также динамически типизированный код (особенно большого объема) ведет себя менее предсказуемо и чтобы с ним работать нужно держать в уме информацию о том где какие типы.
## Фундаментальные типы
Большинство языков имеют некоторое количество базовых (ака фундаментальных, ака простых) типов, которые доступны всегда, в любом месте кода. Некоторые базовые типы ты видел в статье по ссылке выше. Также фундаментальные типы сами по себе не из чего не состоят. По этому, кстати, `String` не является фундаментальным типом, ведь он состоит из массива `Char`'ов, а вот сами по себе `Char`'ы это фундаментальный тип.
## Составные типы
На одних только фундаментальных типах далеко не уедешь. По этому нужен способ выражать комбинации простых типов и их свойства. Для этого используются составные типы. Полноценно составные типы котлина рассматриваются в главе про ООП, здесь только концептуально.
Если проводить аналогию, то простыми типами являются колесо, двигатель, корпус, руль. У каждого из них есть своя конструкция и свое поведение которые описывают их чертежи-типы. Из колеса, двигателя, корпуса и руля можно собрать машину. Для машины будет свой чертеж описывающий как и из чего она собирается, какие свойства у нее есть (ехать). Этот чертеж будет новым составным типом, а каждая конкретная машина собранная по этому чертежу - значением этого типа.
# Операторы
- https://www.w3schools.com/kotlin/kotlin_operators.php
- https://www.geeksforgeeks.org/kotlin-operators/
==Котлин делит операторы на следующие группы:
	Арифметические операторы(`+`/ `-`/`*`/`/`/`%`/`++`/`--`)
	Операторы присваивания(`=`/`+=(работает как x=x+y, по подобному принципу работают и другие операторы этой группы)`/`-=`/`*=`/`/=`/`%=`)
	Операторы сравнения(`==(равно)`//`!=(не равно)`/`<(меньше)`/`>(больше)`/`>=(больше или равно)`/`<=(меньше или равно)`)
	Логические операторы (`&&(логическое и)`/`||(логическое или)`/`!(логическое нет)`)
	Bitwise операторы(`shl(signed shift left)`/`shr(signed shift right)`/`ushr(unsigned shift right)`/`and(bitwise and)`/`or(bitwise or)`/`xor(bitwise xor)`/`inv(bitwise inverse))`==
Каждый из операторов может быть использован как метод для значения переменной. Пример: `x.plus(y)



- [x] Задание 6
Что такое операнды?
==Это значение переменной над которой происходит операция с помощью оператора==
- [ ] Задание 7
Если имеется выражение из нескольких операторов например `1 + 1 * 2 == 4`, в каком порядке они будут вычисляться? Что выполнится раньше, сложение или умножение?
Если в выражении один оператор выполняется раньше другого, это значит что у него выше `приоритет`
Если в выражении у всех операторов одинаковый приоритет, они будут выполняться по очереди с лева на право, как здесь: `1 + 3 - 2`
Эксперементально выясни какие операторы приоритетнее каких и выпиши в список в порядке убывания приоритетоности. Наиболее приоритетные сверху, наименее снизу. Операторы с одинаковым приоритетом на одной строчке.
==Здесь==
> [!info]+ Правильный ответ под спойлером
> - `++`, `--` (postfix - пишущиеся справа: `a++`)
> -  `-`, `+`, `++`, `--`, `!` (prefix - пишущиеся слева: `++a`)
> - `*`, `/`, `%`
> - `+`, `-`
> - `<`, `>`, `<=`, `>=`
> - `==`, `!=`
> - `&&`
> - `|`
> - `=`, `+=`, `-=`, `*=`, `/=`, `%=`

- [x] Задание 8
Круглые скобки изменяют очередность выполнения кода. Сначала вычисляется выражение внутри скобок и уже потом снаружи.
```kotlin
fun main() {
	// Расставь в этом коде круглые скобки так что бы при выполнении печаталось 0
	println(((7 - 6.0) / 2 + 2)% 2)
}
```
# Bool
https://www.w3schools.com/kotlin/kotlin_booleans.php
# Ввод
Для чтения текста из стандартного ввода имеется функция `readline()`. К сожалению в веб песочнице нет возможности ввести текст в `stdin` программы и `readline()` всегда возвращает `null`. Энивей такая функция существует и при вызове возвращает либо прочитанную строку, либо `null`.
# If, else, when

- https://www.w3schools.com/kotlin/kotlin_conditions.php
- https://www.w3schools.com/kotlin/kotlin_when.php
- https://www.geeksforgeeks.org/kotlin-if-else-expression/
- https://www.geeksforgeeks.org/kotlin-when-expression/
==if..else и when можно использовать как statement(любая конструкция которую можно выполнить) или как expression(любая конструкция которую можно выполнить и она вернёт что-то) в Котлине.
When является местным Switch, синтаксис же каждого кейса такой: условие -> выражение.
В котлине все выражения if  и when могут возвращать значения (это называется тернарностью)
В условии if должен быть булевый результат==
- [x] Задание 9
```kotlin
fun main() {
	var a = 11
   
    println(if(i%2==0){i}else{-1*a})
	// Напиши в ОДНУ строчку без ; код который печатает значение a, если а четное и результат -1*a если a нечетное. Используй только один вызов функции печати
	// Здесь и во всех задачах далее подразумевается что твой код должен корректно работать для любого значения переменной(включая 0 и 1), а не только для указанного
	// При решении здачи убедись что это так
}
```
# While, do
- https://www.w3schools.com/kotlin/kotlin_while_loop.php
- https://www.geeksforgeeks.org/kotlin-while-loop/
==Цикл while выполняется пока условие является верным то есть true==
- [x] Задание 10
```kotlin
// Факториал числа это произведение всех чисел от него до единицы
// факториал 0  = 1
// факториал 1  = 1
// факториал 2  = 1 * 2 = 2
// факториал 3  = 1 * 2 * 3 = 6
// факториал 4  = 1 * 2 * 3 * 4 = 24
// факториал 5  = 1 * 2 * 3 * 4 * 5 = 120
// факториал 6  = 1 * 2 * 3 * 4 * 5 * 6 = 720
// факториал 7  = 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040
// факториал 8  = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 = 40320
// факториал 9  = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 = 362880
// факториал 10 = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 = 3628800
// ...
fun main() {
    var nom = 0 
    var i = 1
    var x = 1
    	while(x<=nom){
      		i=i*x
      		x++
    	}
    println(i)
    // Напиши код который печатает факториал числа nom
}
```
- [x] Задание 11
```kotlin
// Числа Фибоначчи это ряд числел в котором каждое число равно сумме двух предыдущих
// Номер числа в ряде: 0  1  2  3  4  5  6  7  8  9 10 ...
// Число             : 1  1  2  3  5  8 13 21 34 55 89 ...
fun main() {
    var nom = 5
    var y = 0
    var z = 1
    	while(0<nom--){
            var i=z+y
            y = z
            z = i
    	}
        println(z)
    // Напиши код который печатает число Фибоначчи под номером nom
}
```
- [x] Задание 12
```kotlin
// ASCII елочка

// Пример:
//    A
//   /|\
//  /-|-\
// /--|--\
//#########

// Елочка состоит из уровней; одна строчка - один уровень
// На каждом следующем уровне на 2 больше непробельных символов
// На вершине всегда A
// Нижний уровень (только если он не единственный) полностью заполнен символами #
// На всех уровнях кроме верхнево и нижнего
//   по краям / и \
//   в центре | (ствол)
//   все остальное заполнено - (ветка)

// На кадом уровне слева есть некоторое колличество пробелов
// На нижнем уровне оно нулевое
// На всех остальных уровнях их столько чтобы елка имела правильную форму

// Примеры елок разной высоты

//A

// A
//###

//  A
// /|\
//#####

//   A
//  /|\
// /-|-\
//#######

fun main() {
    var height = 5
    // Напиши код, печатающий елку с высотой height
}



Упрощённая ёлочка
//1    #1
//2   ###3
//3  #####5
//4 #######7
//5#########9
fun main() {
    var height = 5
    var x = 1
    while(height>=x){
       var c = ""
       var i = height - x
       var z = x + x - 1
        while(0<i--){
            c +=" "
        }
        while(0<z--){
            c +="#"
        }
        
        println(c)
        x++
    }
    
    // Напиши код, печатающий елку с высотой height
}
Усложнённая ёлочка
/*  A 
   /|\ 
  /-|-\ 
 /--|--\ 
#########
*/
fun main() {
    var height = 5
    var x = 1
    var v = -1
    while(height>=x){
        var c = ""
        var i = height - x
        var z = x + x - 1
        var k = 1
        var f = 1
        v++
        while(0<i--){
            c +=" "
        }
        if(x==1){
        	c += "A"
        }else{
            if(x==2){
             c+="/|\\"   
            }else{
                c+="/"
                while(k<v){
                    c+="-"
                    k++
                }
                c+="|"
                while(f<v){
                    c+="-"
                    f++
                }
                c+="\\"
                }
                
            if(x == height){
                c=""
                while(0<z--){
                    c +="#"
                }
          	}
     	}	
    	println(c)
    	x++
    }

    // Напиши код, печатающий елку с высотой height
}
Код Андрея
fun main() {
    var height = 5
    var x = 1
    while(height>x){
        var c = ""
        var i = height - x
        var z = x * 2 - 1
        while(0<i--){
            c +=" "
        }
        if(x==1){
        	c += "A"
        }else{
            var k = 1
            c+="/"
            while(k<=x-2){
                c+="-"
                k++
            }
            k = 1
            c+="|"
            while(k<=x-2){
                c+="-"
                k++
            }
            c+="\\"
     	}	
    	println(c)
    	x++
    }
    if (height > 1) {
        var z = height * 2 - 1
        while(0<z--){
            print("#")
        }
    }
    // Напиши код, печатающий елку с высотой height
}
```
# Break, continue, label
- https://www.w3schools.com/kotlin/kotlin_break.php
- https://www.geeksforgeeks.org/kotlin-unlabelled-break/
- https://www.geeksforgeeks.org/kotlin-labeled-continue/
Вот конкретно эта тема почему-то раскрыта очень плохо в статьях. На `w3schools` про label вообще не говорится. А на `geeksforgeeks` какая-то странная хрень: `break` рассматривается только без лейблов, а `continue` только с лейблами.
Тем важнее тебе сделать по этой теме заметку своими словами.
==Break - завершение цикла==
==Continue - пропуск итерации в цикле до следующей==
==Практически всегда они пишутся с условием выполнения==
==Label - обозначается `label_name@`, нужен для того чтобы можно было указывать Continue и Break на определённый цикл. Continue по отношению к лейблу пишется как `continue@lable_name` а Break `break@lable_name`==

# Массивы
- https://www.w3schools.com/kotlin/kotlin_arrays.php
==Массивы используются для хранения нескольких значений в одной переменной вместо создания отдельных переменных для каждого значения.==
При получении элемента массива вместо такой записи `var a = arr[0]` можно использовать такую `var a = arr.get(0)`
При записи элемента массива вместо такой записи `arr[0] = a` можно использовать такую `arr.set(0, a)`

При объявлении массива можно явно указывать тип элементов
```kotlin
val num = arrayOf(1, 2, 3, 4)   //implicit type declaration
val num = arrayOf<Int>(1, 2, 3) //explicit type declaration
val num: Array<Int> = arrayOf(1, 2, 3) // also explicit type declaration
```

Массивы в Котлине нельзя увеличивать или уменьшать добавляя и убирая элементы. Для этого есть списки. Они будут рассмотрены ниже.
# Аргументы программы
Когда одна программа запускает другую, первая может передать второй массив текстовых аргументов.
==Аргументами программы являются данные которые передаёт другая программа моей программе при запуске в функции main==
```kotlin
fun main() {
	// Если писать main таким образом
	//  то полученные при запуске аргументы будут проигнорированны
}
```

```kotlin
fun main(args: Array<String>) {
	// Если писать main вот так
	//  то полученные агрументы будут в массиве в переменной args
	println(args[0]) // печать первого аргумента
}
```

В [веб песочнице](play.kotlinlang.org) можно указывать аргументы передаваемые программе при запуске:
![[Pasted image 20231013064208.png|400]]
# For, Range
- https://www.w3schools.com/kotlin/kotlin_for_loop.php
- https://www.w3schools.com/kotlin/kotlin_ranges.php
- https://www.geeksforgeeks.org/kotlin-for-loop/
==В Kotlin цикл for используется для перебора массивов(`Array`), диапазонов(`Range`) и других элементов, содержащих счетное количество значений.
Range - это не изменяемая в процессе переменная==
- [x] Задание 13
```kotlin
fun main() {
	// Перепиши этот код с цикла while на цикл for range
    var i = 15
    do {
        i -= 2
        println(i)
    }while(i > 5)
}
Моё решение
fun main() {
    var c = 15
	for(i in 1..5){
        c-=2
        println(c)
    }    
}
Вот второе по приколу
fun main() {
    val nums = arrayOf(13, 11, 9, 7, 5)
	for(i in nums){
        println(i)
    }    
}
```
- [ ] Задание 14
```kotlin
fun main() {
    // Напиши код который печататет все числа от 1 до 100 включительно
    // Если число кратно трем, вместо него должно печататься слово Fizz
    // Если число кратно пяти, вместо него должно печататься слово Buzz
    // Если число кратно и пяти и трем, вместо него должно печататься FizzBuzz
    // Постарайся написать код который занимает как можно меньше текста
    //   не считая переносы строк и прочий незначаший текст
}
```
FizzBuzz это, кстати, классическая задачка для собеседований на джунов

---
==Дальше пока не сделано==
---
# Строки
- Экранирование в char и String
- Указание 
- Многострочные строки
- Форматирование строк
- Методы работы со строками
	- split
	- find
	- Upper
	- Lower
- Простой парсинг в числа
- Дроч с многосимвольными UNICODE глифами
- Подкаст Тонского
- ASCII таблица
- UTF-8 UNICODE
# Коллекции
- Range к ним относится
## Arraylist
## Hashmap

# Null
- https://www.geeksforgeeks.org/kotlin-elvis-operator/

# Функции
## Чистые функции
## Функции как значения
## Лямбды
## Функции высшего порядка
## Каррирование
## Замыкания
## Лейблы в лямбдах
- https://kotlinlang.org/docs/returns.html#return-to-labels
## Стек
## Минусы функционального программирования
## Плюсы функционального программирования
# Ленивость
- [ ] Задание ?
Что будет напечатано при выполнении такого кода? Попытайся сформулировать почему вывод именно такой и в каком порядке вычисляются выражения
Правильный ответ ниже под спойлером
```kotlin
fun a(): Boolean {val a = 11
    println("A")
    return true;
}

fun b(): Boolean {
    println("B")
    return false;
}

fun main() {
	println(a() || b())
	println(b() || a())
	println(a() && b())
	println(b() && a())
}
```
==Твой ответ==
> [!info]- Правильный ответ под спойлером
> В строчке `println(a() || b())` есть несколько вложенных выражений. Чтобы выполнить `println` нужно сначала рассчитать значение в скобках выполнив `a() || b()`. Оператор `||` возвращает истину если хотя бы один из его опрерандов является истиной. Для того чтобы выполнить `a() || b()` сначала нужно выполнить `a()`. Вызов функции a 
# Регулярки
# Больше о числах
## Устройство чисел
## Переполнение
## Signed/Unsigned
## Системы счисления и форматы записи
## Как устроены флоаты
## Проблема арифметики и сравнения флоатов
# Задачки
- ASCII треугольник Серпинского
- Изометрические ASCII параллелепипиды

# OOP
## Изначальная идея ООП
## Паттерны; Банда четырех

# Алгоритмы
- Грокаем алгоритмы
# Тулчейн

# Импорты

# Многопоточность
# Асинхронность

# Стандартная библиотека

# Работа с ФС

# Задачки
- Игра жизнь
- Шахматный движок
	- ядерные шахматы
- ASCII Симуляция жидкости
- ASCII Трассировщик лучей с бубликом
- Lisp
- Forth
# Оформление кода
# Цикломатическая сложность

# Тесты
## Процент покрытия тестами

# Инструменты сборки
## Maven
## Graddle
## Ant

# Подключение внешних библиотек

# Публикация своей библиотеки

# Оформление репозитория

# Реализация 3a

# IDE
## Отладка

# Графика
## Графическая жизнь
## Продвинутая жизнь от foo25

# JVM
## GaalVM

# Проекты
- SayMyName - утилита генерирующая имена по шаблону
- Парсер 3a
- animfetch
- Браузерный редактор 3a
# Словарь
- `Тулчейн` - дословно `tool chain` - набор, как правило связанных, инструментов для работы с чем либо. Например тулчейн языка, тулчейн для разработки под андроид итд ^1
- JVM - виртуальная машина Java 
- Интероп - 
- Транспиляция - 

